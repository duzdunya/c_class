<h1>Syntax ve Semantik farkı</h1>

<h2>Syntax</h2>

<p>Programlama dilinin kuralları, nasıl yazıldığı. Dilin genel yapısını kuralını ifade eder.
Hatalar derleme (compile) esnasında bulunabilir çünkü bu kurallar bellidir ve kontrol edilir.</p>

<p><img src="assets/syntax.webp" width=500></p>

<h2>Semantik</h2>

<p>Kodun nasıl çalışacağını ve anlamını ifade eder.
Semantik hatalar (mesela hatalı hesaplamalar veya ulaşılamayan kod blokları)
Hatalar çalıştırma esnasında bulunur.</p>

<p><img src="assets/egg.jpg" width=500></p>

<hr>


<h1>Dekaration und Definition</h1>

<h2>Deklaration</h2>

<p>Deklarasyon ile değişkenlerin özellikleri, yapıları programa verilir.
Mesela burada bir fonksiyon deklare ediliyor ama tanımlanmıyor (definition).
<code>
int getVolume(int, int, int);
</code></p>

<h2>Definition</h2>

<p>Tanımlama ile programa bu değişkenin, fonksiyonun, yapının ne yapacağı nasıl yapacağı anlatılır.
Değişkenlerde çoğunlukla Declaration ve Definition aynı anda olur.
Mesela burada aynı anda değişken deklare edilir ve tanımlanır:
<code>
int x = 10;
</code>
<br>
<img src="./assets/declaration-definition.webp" width=750></p>

<hr>


<h1>Funktionen</h1>

<h2>Funktion Deklaration</h2>

<p><code>c
int someFunc(float,double,_Bool);
</code>
Deklarasyon birçok defa yapılabilir</p>

<h2>Funktion Definition</h2>

<p><code>c
int someFunc(float x, double y, _Bool isTrue){
printf("do some stuffs\n");
}
</code>
Tanımlama sadece bir defa yapılır.</p>

<h2>Vordeklaration</h2>

<p>Program yukarıdan aşağıya doğru çalıştırılır.
Fonksiyonlar, değişkenler ya da başka şeyler en başta deklare edilmelidir.</p>

<p><img src="assets/pre-declaration.webp" width=500></p>

<h2>Funktionen mit Parametern aufrufen</h2>

<p>Bir fonksiyona parametreleri parantez içine yazarak veririz. Parametrelerde asıl parametreyi değiştirip isteyip istemediğinize ve extra memory'nin sizin için sorun olup olmayacağına. Buna göre iki olay vardır: Call by value ve Call by reference. Burada stack ve heap ayrımı yapılır.
Stack kısa sürelidir LIFO'dur ve hızlıdır. Heap dynamic memory allocation'da kullanılır ve elle geri alan açmak gerekir.</p>

<p><img src="assets/copy-reference.webp" width=500></p>

<h3>Call by value</h3>

<p>Parametrenin kopyası fonksiyona verilir, fonksiyonun kendi hafızasında (stack) tutulur, iş bittikten sonra otomatik silinir.
Manuel hafıza yönetimi gerekmez.</p>

<p><img src="assets/stack-address.webp" width=750></p>

<h3>Call by reference</h3>

<p>Bellek referansı verilir, asıl değer dereferans ile görülebilir veya değiştirilebilir. Bellek az tutar çünkü sadece bir kere oluşturulur ve fonksiyona ise referansı verilir.</p>

<p><img src="assets/heap-address.webp" widht=500></p>

<hr>


<h2>Pointers</h2>

<p>İşaretiçiler * (asterisk) işareti ile ifade edilir.
İşaretçiler bellek adreslerini tutarlar, işaretçinin veri türü işaret ettiği adreste yer alan veri türüne göre verilmelidir. Eğer veri türünü bilmiyorsak veya henüz belli değilse void kullanılır.
Değere dereferans işareti ile ulaşılır * (Asterisk)
Bana göre işaretçiler çoğunlukla arka arkaya koyulan verilerde kullanılır. Mesela Stringlerde (char<em>) aslında pointer kullanırız çünkü her bir bellek adresi ayrı harfi tutar ve bu pointer cümlenin ilk başının adresine işaret eder &amp;string[0].
Pointer aritmetiği ile de değerler ulaşılınır. mesela string</em> için: string + 1 = string[1]
Bir sonraki adrese işaret eder.</p>

<p><img src="assets/char.webp" width=500></p>

<p>Dereferans için sadece asterisk kullanmak gerekmez.</p>

<p>Dereferans örnekleri
<code>
x.wert //değerler için
x-&gt;wert //işaretçiler için
x[3]
printf("%s",x);
</code></p>

<h4>Call by Reference und Pointer Beispiel:</h4>

<p><img src="assets/beispiel.png" width=500></p>

<h3>integer array.</h3>

<p><code>
int arr[10];
</code></p>

<h3>integerlardan oluşan pointer array.</h3>

<p><code>
int* arr[10];
</code></p>

<h3>structurlardan oluşuan pointer array.</h3>

<p><code>
Person* students[20];
</code></p>

<h4>Call by Reference ve Pointer örneği:</h4>

<p><img src="assets/beispiel.webp" width=750></p>
