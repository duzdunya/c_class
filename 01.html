<h1>Unterschiedung zwischen syntax und semantik</h1>

<h2>Syntax</h2>

<p>Regeln von Sprache, wie Programme geschrieben werden. Bezieht sicht auf die Struktur und Anordnung der Sprache.
Fehler werden beim Compilezeit gefunden.</p>

<p><img src="assets/syntax.webp" width=500></p>

<h2>Semantik</h2>

<p>Bezieht sich darauf, was der Code tatsächlich bewirken soll.
Semantische Fehler (z. B. falsche Berechnungen oder nicht erreichte Programmziele.
Fehler werden bei der Ausführung gefunden.</p>

<p><img src="assets/egg.jpg" width=500></p>

<hr>


<h1>Dekaration und Definition</h1>

<h2>Deklaration</h2>

<p>Mit der Deklaration wird dem Programm die Eigenschaften vom Bezeichner klargemacht.
Hier wird eine Funktion deklariert aber nicht definiert.</p>

<h2>Definition</h2>

<p>Mit der Definition wird der Bezeichner erklärt, was er machen wird (für Funktionen). Bei Variablen aber declaration und definition findet gleichzeitig statt.
<br>
<img src="./assets/declaration-definition.webp" width=750></p>

<hr>


<h1>Funktionen</h1>

<h2>Funktion Deklaration</h2>

<p><code>c
int someFunc(float,double,_Bool);
</code></p>

<p>Deklaration kann mehrmals vorhanden sein.</p>

<h2>Funktion Definition</h2>

<p><code>c
int someFunc(float x, double y, _Bool isTrue){
printf("do some stuffs\n");
}
</code></p>

<p>Definition sollte einmal gegeben werden.</p>

<h2>Vordeklaration</h2>

<p>Programm wird sequentiell von oben nach unten ausgeführt.
Funktionen, Variablen odere andere Sachen müssen vorerst zum Beginn deklariert werden.</p>

<p><img src="assets/pre-declaration.webp" width=500></p>

<h2>Funktionen mit Parametern aufrufen</h2>

<p>Man gibt die Parameter in die Funktion innerhalb Klammern. Bei der Parametern muss man darauf achten, auf was man machen will. Z.B. wenn man die eigentliche Parametereigenschaften ändern möchte, sollte man daher Referenz geben. Wenn es aber um keine größe Memory handelt und man echte Parameter nicht ändern möchte, ruft man Funktionen mit Parameterwerten.
Daher handelt es sich dabei um den Speicher also die Differenzierung zwischen Stack und Heap.</p>

<p><img src="assets/copy-reference.webp" width=500></p>

<h3>Call by value</h3>

<p>Kopie des Wertes wird in die Funktion gegeben, der im Stack gespeichert wird.
Man ist nicht verantwortlich für das Löschen vom Speicher. Werte werden automatisch im Stack von Funktion am Ende gelöscht.</p>

<p><img src="assets/stack-address.webp" width=750></p>

<h3>Call by reference</h3>

<p>Man gibt den Speicheraddress in die Funktion.
In funktion wird die gleiche Address von Parameter gehandelt.</p>

<p><img src="assetes/heap-address.webp" widht=500></p>

<hr>


<h2>Pointers</h2>

<p>Pointer enthalten die Speicheradresse, der Datentyp vor Pointer zeigt auf Datentyp des Wertes auf. Wenn man den Datentyp nicht weiß, der auf Werteadresse zeigt, benutzt man void Pointer (void<em>). Man erreicht den Wert des Pointers via Dereferenzierung.
Meine Erfahrungen nach benötigen und benutzen wir Pointer meistens für aneinandergebundene Werte, z.B. bei Strings (char</em>) benutzen wir eigentlich Pointer, die auf Anfang des Strings zeigt. Mit Pointerarithmetik erreicht man damit einzelne Werte von Strings wie string[1], string[n] etc.</p>

<p><img src="assets/char.webp" width=500></p>

<p>Da sagt man, dass * (asterisk) zu Dereferenzierung genutzt wird aber tatsächlich nutzt man nicht nur das zur Dereferenzierung.</p>

<h3>Dereferenzierung Beispiel:</h3>

<p><code>
x.wert
x-&gt;wert
x[3]
printf("%s",x);
*&amp;x.wert
</code>
Mit diesen kann man auch die Werte bekommen, als ob x Pointer ist.</p>

<h3>Array von integers.</h3>

<p><code>
int arr[10];
</code></p>

<h3>Array von Pointers von integers.</h3>

<p><code>
int* arr[10];
</code></p>

<h3>Array von Pointers von structures.</h3>

<p><code>
Person* students[20];
</code></p>

<h4>Call by Reference und Pointer Beispiel:</h4>

<p><img src="assets/beispiel.webp" width=750></p>
